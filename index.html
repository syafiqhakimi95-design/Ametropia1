<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cikgu Mata Pro: Fixed</title>
    <style>
        :root { --bg: #f8fafc; --primary: #2563eb; --text: #0f172a; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* STAGE */
        .stage-container { flex: 1; position: relative; background: #fff; border-bottom: 2px solid #cbd5e1; overflow: hidden; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        
        /* UI */
        .overlay-top-left { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; }
        .badge { background: rgba(255,255,255,0.95); padding: 5px 10px; border-radius: 15px; border: 1px solid #ccc; font-weight: bold; font-size: 0.75rem; display: flex; align-items: center; gap: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        
        .toolbar { position: absolute; bottom: 10px; right: 10px; display: flex; gap: 5px; background: #fff; padding: 5px; border-radius: 8px; border: 1px solid #cbd5e1; box-shadow: 0 4px 10px rgba(0,0,0,0.1); z-index: 10; }
        .tool-btn { width: 36px; height: 36px; border: 1px solid #e2e8f0; background: #fff; border-radius: 6px; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .tool-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        
        .color-tray { display: flex; gap: 5px; border-left: 1px solid #ddd; margin-left: 5px; padding-left: 5px; align-items: center; }
        .color-dot { width: 20px; height: 20px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; }
        .color-dot.selected { border-color: #333; transform: scale(1.1); }

        /* CONTROLS */
        .controls-area { flex: 0 0 auto; max-height: 50%; overflow-y: auto; background: var(--bg); padding: 15px; }
        .card { background: #fff; padding: 12px; border-radius: 10px; border: 1px solid #e2e8f0; margin-bottom: 10px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        h3 { margin: 0 0 8px 0; font-size: 0.9rem; color: var(--primary); display: flex; justify-content: space-between; }
        input[type=range] { width: 100%; height: 30px; accent-color: var(--primary); }
        select, input[type=number] { padding: 8px; border: 1px solid #ccc; border-radius: 6px; width: 100%; font-size: 0.9rem; background: #fff; }
        .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-top: 5px; }
        .labels { display: flex; justify-content: space-between; font-size: 0.75rem; color: #64748b; font-weight: bold; }
        .spec-controls { display: flex; gap: 10px; }
        .spec-group { flex: 1; }
        .spec-group label { font-size: 0.7rem; font-weight: bold; color: #64748b; display: block; margin-bottom: 4px; }
        
        /* METER */
        .meter-container { height: 10px; background: #e2e8f0; border-radius: 5px; overflow: hidden; margin-top: 5px; position: relative; }
        .meter-bar { height: 100%; width: 0%; background: #2563eb; transition: width 0.1s, background 0.2s; }
        .meter-marker { position: absolute; top:0; bottom:0; width: 2px; background: rgba(0,0,0,0.5); z-index: 2; }
    </style>
</head>
<body>

<div class="stage-container">
    <canvas id="simCanvas"></canvas>
    <div class="overlay-top-left">
        <div class="badge">
            <div id="statusDot" class="dot" style="background:green;"></div>
            <span id="statusText">Clear</span>
        </div>
        <div id="drawStatus" class="badge" style="display:none; color:#dc2626; border-color:#dc2626; background:#fff5f5;">
            <span>‚úé Zoom Disabled</span>
        </div>
    </div>
    <div class="toolbar">
        <button class="tool-btn" id="btnReset">‚Ü∫</button>
        <button class="tool-btn" id="btnPen">‚úé</button>
        <div class="color-tray" id="colorTray" style="display:none;">
            <div class="color-dot selected" style="background:#ef4444;" data-c="#ef4444"></div>
            <div class="color-dot" style="background:#2563eb;" data-c="#2563eb"></div>
            <div class="color-dot" style="background:#000000;" data-c="#000000"></div>
        </div>
        <button class="tool-btn" id="btnClear">üóëÔ∏è</button>
    </div>
</div>

<div class="controls-area">
    <div class="card" style="border-left: 4px solid var(--primary);">
        <h3><span>Lens Response</span> <span id="accVal">0.00 D</span></h3>
        <div class="meter-container">
            <div id="accBar" class="meter-bar"></div>
            <div id="funcLimitMarker" class="meter-marker"></div>
        </div>
        <div class="labels"><span>0 D</span><span>Max: <span id="maxAmpVal">10</span>D</span></div>
    </div>

    <div class="card">
        <h3>Patient Profile</h3>
        <select id="condSelect">
            <option value="emmetropia">Emmetropia (0.00)</option>
            <option value="myopia">Myopia (-2.50 D)</option>
            <option value="hyperopia">Hyperopia (+2.50 D)</option>
        </select>
        <div class="row">
            <label>Age:</label>
            <input type="number" id="ageInput" value="40" style="width:60px; text-align:center;">
        </div>
    </div>

    <div class="card">
        <h3>Rx Correction</h3>
        <div class="spec-controls">
            <div class="spec-group">
                <label>Distance</label>
                <input type="number" id="specInput" value="0.00" step="0.25" min="-10" max="10">
            </div>
            <div class="spec-group" id="addGroup" style="display:none;">
                <label>Add</label>
                <input type="number" id="addInput" value="0.00" step="0.25" min="0" max="4">
            </div>
        </div>
    </div>

    <div class="card">
        <h3>Object Distance ‚ö´</h3>
        <input type="range" id="distSlider" min="0" max="100" step="0.5" value="100">
        <div class="labels"><span>5cm</span><span>Infinity</span></div>
    </div>
    <div style="height:50px;"></div>
</div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    const ui = {
        accBar: document.getElementById('accBar'),
        funcLimitMarker: document.getElementById('funcLimitMarker'),
        distSlider: document.getElementById('distSlider'),
        condSelect: document.getElementById('condSelect'),
        ageInput: document.getElementById('ageInput'),
        accVal: document.getElementById('accVal'),
        maxAmpVal: document.getElementById('maxAmpVal'),
        statusText: document.getElementById('statusText'),
        statusDot: document.getElementById('statusDot'),
        specInput: document.getElementById('specInput'),
        addInput: document.getElementById('addInput'),
        addGroup: document.getElementById('addGroup'),
        btnPen: document.getElementById('btnPen'),
        btnReset: document.getElementById('btnReset'),
        btnClear: document.getElementById('btnClear'),
        colorTray: document.getElementById('colorTray'),
        drawStatus: document.getElementById('drawStatus')
    };

    let state = {
        condition: 'emmetropia', age: 40, maxAmp: 3.0, funcAmp: 3.0, refError: 0,
        specPower: 0, addPower: 0, accEffort: 0, actualAcc: 0, objectDistD: 0,
        isBlurred: false, blurReason: ''
    };

    let camera = { scale: 1, x: 0, y: 0 };
    let drawing = { active: false, color: '#ef4444', lines: [] };

    // --- PHYSICS LOGIC ---
    function updatePhysics() {
        state.condition = ui.condSelect.value;
        state.age = Math.max(5, Math.min(100, parseInt(ui.ageInput.value) || 20));
        
        // 1. Max Amplitude (18.5 - 0.3*Age) -> The hard wall
        state.maxAmp = Math.max(0, 18.5 - (0.3 * state.age));
        ui.maxAmpVal.innerText = state.maxAmp.toFixed(2);

        // 2. Functional Blur Point (15 - 0.3*Age) -> Where blur starts
        state.funcAmp = Math.max(0, 15.0 - (0.3 * state.age));
        
        // Marker
        ui.funcLimitMarker.style.left = Math.min(100, (state.funcAmp / 15) * 100) + "%";

        // Add Input Visibility
        if (state.age >= 40) {
            ui.addGroup.style.display = 'block';
        } else {
            ui.addGroup.style.display = 'none';
            state.addPower = 0; ui.addInput.value = 0;
        }

        // Ref Error
        if (state.condition === 'emmetropia') state.refError = 0;
        if (state.condition === 'myopia') state.refError = 2.50; 
        if (state.condition === 'hyperopia') state.refError = -2.50;

        state.specPower = parseFloat(ui.specInput.value) || 0;
        state.addPower = parseFloat(ui.addInput.value) || 0;
        
        recalcVision();
    }

    function recalcVision() {
        // Demand from Slider (100=Infinity, 0=20D/5cm)
        let val = parseFloat(ui.distSlider.value);
        state.objectDistD = (100 - val) / 5;

        // Net Static = RefError + SpecPower. (Myope +2.5 with -2.5 Spec = 0)
        let netStatic = state.refError + state.specPower;
        
        // Needed Acc = Demand - NetStatic - Add
        let needed = state.objectDistD - netStatic - state.addPower;
        if (needed < 0) needed = 0;

        // Physical Clamp
        state.actualAcc = Math.min(needed, state.maxAmp);
        state.accEffort = needed;

        // Blur Check
        state.isBlurred = false;
        state.blurReason = '';

        // 1. Functional Limit Blur
        if (needed > state.funcAmp) {
            state.isBlurred = true;
            state.blurReason = "Near Limit";
        }
        
        // 2. Optical Focus Error
        let totalPower = netStatic + state.addPower + state.actualAcc;
        let error = totalPower - state.objectDistD; // + = Front, - = Back

        if (Math.abs(error) > 0.20) {
            state.isBlurred = true;
            if (error > 0) state.blurReason = "Front Focus";
            else state.blurReason = "Back Focus";
        }

        render();
    }

    // --- RENDER ---
    function render() {
        // UI Updates
        ui.accVal.innerText = state.actualAcc.toFixed(2) + " D";
        let dText = state.objectDistD <= 0.1 ? "Infinity" : (100/state.objectDistD).toFixed(0) + " cm";
        
        // Bar Color
        let barPct = Math.min(100, (state.actualAcc / 15) * 100);
        ui.accBar.style.width = barPct + "%";
        if(state.actualAcc >= state.maxAmp - 0.1) ui.accBar.style.backgroundColor = "#dc2626"; // Max
        else if(state.accEffort > state.funcAmp) ui.accBar.style.backgroundColor = "#f59e0b"; // Strain
        else ui.accBar.style.backgroundColor = "#2563eb"; // Good

        if(state.isBlurred) {
            ui.statusText.innerText = "Blur (" + state.blurReason + ")";
            ui.statusText.style.color = "#dc2626"; ui.statusDot.style.background = "#dc2626";
        } else {
            ui.statusText.innerText = "Clear (" + dText + ")";
            ui.statusText.style.color = "#16a34a"; ui.statusDot.style.background = "#16a34a";
        }

        // Canvas Drawing
        const dpr = window.devicePixelRatio || 1;
        const r = canvas.getBoundingClientRect();
        canvas.width = r.width * dpr; canvas.height = r.height * dpr;
        ctx.resetTransform(); ctx.scale(dpr, dpr);
        ctx.clearRect(0,0,r.width,r.height); // Safe clear

        ctx.save();
        ctx.translate(r.width/2, r.height/2);
        ctx.translate(camera.x, camera.y);
        ctx.scale(camera.scale, camera.scale);

        // Coordinates
        const cx = 100; const cy = 0;
        
        // 1. Eye Body
        ctx.beginPath(); ctx.arc(cx, cy, 60, 0, Math.PI*2);
        ctx.fillStyle = "#fff"; ctx.fill(); ctx.strokeStyle = "#334155"; ctx.lineWidth = 2; ctx.stroke();

        // 2. Cornea
        ctx.beginPath(); ctx.arc(cx - 55, cy, 28, 1.4, 4.88);
        ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.fill(); ctx.strokeStyle = "#94a3b8"; ctx.lineWidth = 1; ctx.stroke();

        // 3. Specs
        if(state.specPower !== 0) {
            let sx = cx - 90; 
            ctx.beginPath();
            if(state.specPower < 0) {
                ctx.moveTo(sx-3, -35); ctx.quadraticCurveTo(sx+2, 0, sx-3, 35); 
                ctx.lineTo(sx+3, 35); ctx.quadraticCurveTo(sx-2, 0, sx+3, -35); ctx.lineTo(sx-3, -35);
            } else {
                ctx.moveTo(sx, -35); ctx.quadraticCurveTo(sx+6, 0, sx, 35); 
                ctx.moveTo(sx, -35); ctx.quadraticCurveTo(sx-6, 0, sx, 35);
            }
            ctx.fillStyle = "rgba(200, 230, 255, 0.5)"; ctx.fill(); ctx.strokeStyle = "#64748b"; ctx.stroke();
            ctx.fillStyle = "#2563eb"; ctx.font = "10px sans-serif"; ctx.textAlign="center"; 
            ctx.fillText(state.specPower.toFixed(2), sx, -40);
        }

        // 4. Iris
        ctx.beginPath();
        ctx.moveTo(cx-50, cy-40); ctx.lineTo(cx-50, cy-15);
        ctx.moveTo(cx-50, cy+40); ctx.lineTo(cx-50, cy+15);
        ctx.strokeStyle = "#854d0e"; ctx.lineWidth = 5; ctx.stroke();

        // 5. Lens
        let growth = state.actualAcc * 0.7;
        let th = Math.min(5 + growth, 16);
        ctx.beginPath(); ctx.ellipse(cx-35, cy, th, 32, 0, 0, Math.PI*2);
        ctx.fillStyle = "#bae6fd"; ctx.fill(); ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 2; ctx.stroke();

        // 6. Object
        let slide = parseFloat(ui.distSlider.value)/100; // 0..1
        // Map slide to visual X. Infinity = -400, Close = cx-140 (-40)
        let objX = -400 + (slide * 360); // -400 to -40
        
        if (state.objectDistD < 0.1) {
            ctx.fillStyle = "#333"; ctx.font = "30px sans-serif"; ctx.fillText("‚àû", -380, 10);
        } else {
            ctx.beginPath(); ctx.arc(objX, 0, 5, 0, Math.PI*2); ctx.fillStyle = "#000"; ctx.fill();
        }

        // 7. Rays
        let corneaX = cx - 60;
        let lensX = cx - 35;
        let specX = cx - 90;
        ctx.strokeStyle = "#f59e0b"; ctx.lineWidth = 2/camera.scale; ctx.beginPath();
        
        let rayStart = state.objectDistD < 0.1 ? -1000 : objX;
        
        if (state.objectDistD < 0.1) {
            // Parallel
            ctx.moveTo(rayStart, -10); 
            if(state.specPower!==0) ctx.lineTo(specX, -10);
            ctx.lineTo(corneaX, -15); ctx.lineTo(lensX, -20);
            
            ctx.moveTo(rayStart, 10); 
            if(state.specPower!==0) ctx.lineTo(specX, 10);
            ctx.lineTo(corneaX, 15); ctx.lineTo(lensX, 20);
        } else {
            // Diverging
            ctx.moveTo(rayStart, 0); 
            if(state.specPower!==0) { ctx.lineTo(specX, -12); ctx.lineTo(corneaX, -15); } 
            else { ctx.lineTo(corneaX, -15); }
            ctx.lineTo(lensX, -20);

            ctx.moveTo(rayStart, 0); 
            if(state.specPower!==0) { ctx.lineTo(specX, 12); ctx.lineTo(corneaX, 15); } 
            else { ctx.lineTo(corneaX, 15); }
            ctx.lineTo(lensX, 20);
        }
        ctx.stroke();

        // 8. Retina Image
        let retinaX = cx + 60;
        // Focus calc
        let netStatic = state.refError + state.specPower;
        let tot = netStatic + state.addPower + state.actualAcc;
        let err = tot - state.objectDistD;
        
        let focusX = retinaX;
        if(Math.abs(err) > 0.2) focusX = retinaX - (err * 8);

        ctx.strokeStyle = "#3b82f6"; ctx.beginPath();
        ctx.moveTo(lensX, -20); ctx.lineTo(focusX, 0);
        ctx.moveTo(lensX, 20); ctx.lineTo(focusX, 0);
        ctx.stroke();

        // Blur Dot
        ctx.beginPath();
        if(state.isBlurred) {
            ctx.fillStyle = "rgba(220, 38, 38, 0.6)"; ctx.arc(retinaX, 0, 6, 0, Math.PI*2);
        } else {
            ctx.fillStyle = "#16a34a"; ctx.arc(retinaX, 0, 3, 0, Math.PI*2);
        }
        ctx.fill();

        // 9. Ink
        ctx.lineCap = "round"; ctx.lineJoin = "round";
        drawing.lines.forEach(l => {
            ctx.beginPath(); ctx.strokeStyle = l.color; ctx.lineWidth = 3 / camera.scale;
            if (l.points.length > 0) { ctx.moveTo(l.points[0].x, l.points[0].y); for(let i=1; i<l.points.length; i++) ctx.lineTo(l.points[i].x, l.points[i].y); }
            ctx.stroke();
        });

        ctx.restore();
    }

    // --- EVENTS ---
    // Pointer
    let evCache=[]; let prevDiff=-1;
    function getPtr(e){const r=canvas.getBoundingClientRect(); return{x:e.clientX-r.left, y:e.clientY-r.top};}
    function toW(x,y){const r=canvas.getBoundingClientRect(); return{x:(x-r.width/2-camera.x)/camera.scale, y:(y-r.height/2-camera.y)/camera.scale};}

    canvas.addEventListener('pointerdown', e=>{
        evCache.push(e); canvas.setPointerCapture(e.pointerId);
        if(drawing.active && evCache.length===1){
            const p=getPtr(e); drawing.lines.push({color:drawing.color, points:[toW(p.x,p.y)]}); render();
        }
    });
    canvas.addEventListener('pointermove', e=>{
        const i=evCache.findIndex(ev=>ev.pointerId===e.pointerId); if(i>-1)evCache[i]=e;
        if(drawing.active && evCache.length===1){
            const p=getPtr(e); drawing.lines[drawing.lines.length-1].points.push(toW(p.x,p.y)); render();
        } else if(!drawing.active) {
            if(evCache.length===2){
                const d=Math.hypot(evCache[0].clientX-evCache[1].clientX, evCache[0].clientY-evCache[1].clientY);
                if(prevDiff>0){ let s=camera.scale+(d-prevDiff)*0.01; if(s>0.5&&s<5)camera.scale=s; } prevDiff=d; render();
            } else if(evCache.length===1){ camera.x+=e.movementX; camera.y+=e.movementY; render(); }
        }
    });
    const up=e=>{
        const i=evCache.findIndex(ev=>ev.pointerId===e.pointerId); if(i>-1)evCache.splice(i,1);
        canvas.releasePointerCapture(e.pointerId); if(evCache.length<2)prevDiff=-1;
    };
    canvas.addEventListener('pointerup', up); canvas.addEventListener('pointercancel', up);
    canvas.addEventListener('wheel', e=>{ if(!drawing.active){e.preventDefault(); let s=camera.scale+(e.deltaY>0?-0.1:0.1); if(s>0.5&&s<5){camera.scale=s; render();}} }, {passive:false});

    // UI Listeners
    ui.distSlider.addEventListener('input', recalcVision);
    ui.condSelect.addEventListener('change', updatePhysics);
    ui.ageInput.addEventListener('change', updatePhysics);
    ui.specInput.addEventListener('input', updatePhysics);
    ui.addInput.addEventListener('input', updatePhysics);
    
    ui.btnPen.addEventListener('click', ()=>{ 
        drawing.active=!drawing.active; 
        ui.colorTray.style.display=drawing.active?'flex':'none'; 
        ui.drawStatus.style.display=drawing.active?'flex':'none';
    });
    ui.btnClear.addEventListener('click', ()=>{ drawing.lines=[]; render(); });
    ui.btnReset.addEventListener('click', ()=>{ camera={scale:1,x:0,y:0}; render(); });
    
    document.querySelectorAll('.color-dot').forEach(d=>d.addEventListener('click', e=>{
        document.querySelectorAll('.color-dot').forEach(x=>x.classList.remove('selected'));
        e.target.classList.add('selected'); drawing.color=e.target.dataset.c;
    }));

    window.addEventListener('resize', render);
    updatePhysics();
</script>
</body>
</html>
